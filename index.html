<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Trading Strategy Simulator</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
/* === Base layout (mobile-first) === */
body {
  font-family: Arial, sans-serif;
  background: #111;
  color: #eee;
  padding: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
}

.settings {
  text-align: left;
  display: flex;
  flex-direction: column;
  width: 100%;
  max-width: 500px;
}

.settings .row {
  display: flex;
  align-items: center;
  margin-top: 8px;
}
.settings label {
  margin-left: 8px;
  font-size: 14px;
  white-space: nowrap;
}
.settings input, select {
  padding: 4px;
  width: 95px;
  text-align: center;
  background: #222;
  color: #eee;
  border: 1px solid #444;
}

#autoControls button,
#toggleModel {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  font-size: 14px;
  font-weight: bold;
  cursor: pointer;
  background: #333;
  color: #eee;
  border: 1px solid #666;
  transition: background 0.2s;
}
#toggleModel {
  width: auto;
  border-radius: 10px;
  padding: 8px;
  height: auto;
  margin-top: 10px;
}
#autoControls button:hover,
#toggleModel:hover {
  background: #555;
}

#history {
  margin-top: 20px;
  max-height: 700px;
  overflow-y: auto;
  overflow-x: hidden;
  border-top: 1px solid #333;
  padding-top: 10px;
  font-family: monospace;
  text-align: left;
  white-space: normal;
  width: 100%;
}

.main {
  text-align: center;
  flex-grow: 1;
  width: 100%;
  max-width: 1000px;
}

#autoControls {
  margin-top: 15px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
}

#status {
  margin-top: 20px;
  font-size: 18px;
  display: none;
}

#stats {
  margin-top: 20px;
  border-top: 1px solid #333;
  padding-top: 10px;
  font-family: monospace;
  text-align: left;
}

.pf-line {
  font-size: 16px;
}
#annualReturn {
  font-weight: bold;
  font-size: 16px;
}

.green { color: lime; }
.red { color: red; }
.smallWin { color: #ddd; }
.bigWin { color: lime; }
.outlierWin { color: lime; }
.smallLoss { color: #FF7F7F; }
.bigLoss, .outlierLoss { color: red; }
.hidden { display: none; }

/* === Charts & Tables (fluid by default) === */
#chartContainer,
#yearlyChart,
#yearlyTable {
  width: 100%;
  max-width: 100%;
  margin: 0 auto;
  overflow-x: auto;
}

#chartContainer canvas,
#yearlyChart {
  display: block;
  width: 100% !important;
  height: auto;
}

#yearlyTable {
  text-align: left;
  font-size: 13px;
  border-collapse: collapse;
  table-layout: fixed;
}
#yearlyTable th, #yearlyTable td {
  padding: 6px 8px;
  border: none;
  text-align: center;
}
table {
  display: block;
  width: 100%;
  max-width: 100%;
  overflow-x: auto;
  box-sizing: border-box;
}

/* === Mobile adjustments === */
@media (max-width: 900px) {
  #autoControls {
    flex-wrap: wrap;
    justify-content: center;
    width: 100%;
    overflow-x: auto;
    text-align: center;
  }

  #autoControls input,
  #autoControls select,
  #autoControls button {
    flex: 1 1 auto;
    min-width: 60px;
  }

  /* better chart scaling on mobile */
  #chartContainer canvas,
  #yearlyChart {
    width: 100% !important;
    height: auto !important;
    max-width: 600px;
  }

  .main {
    padding-top: 10px;
  }
}

/* === Desktop layout === */
@media (min-width: 901px) {
  body {
    flex-direction: row;
    justify-content: center;
    align-items: flex-start;  /* top-align the columns */
    gap: 40px;
    padding: 20px;
  }

  .settings {
    min-width: 260px;
    max-width: 300px;
    flex: 0 0 300px;
  }

  .main {
    flex: 1 1 auto;
    max-width: 1000px;
  }

  #chartContainer,
  #yearlyChart {
    width: 100%;
  }

  #yearlyTable {
    width: 500px;
  }

  #chartContainer canvas {
    width: 100%;
  }

  #history {
    white-space: nowrap;
  }
}

</style>
</head>
<body>

<!-- SETTINGS -->
<div class="settings">
  <div class="row"><input type="number" id="startingTokens" value="100000"><label>Starting Tokens</label></div>
  <div class="row">
    <select id="riskType">
      <option value="fixed">Fixed Tokens</option>
      <option value="percent" selected>% of Total</option>
    </select>
    <label>Risk Type</label>
  </div>
  <div class="row"><input type="number" id="tokensRisked" value="100"><label>Tokens / % Risked per Bet</label></div>
  <div class="row"><input type="number" id="tradesPerYear" value="100"><label>Trades per Year</label></div>

  <!-- Binary model -->
  <div id="binaryInputs">
    <hr><strong>Binary Model</strong>
    <div class="row"><input id="binWinPct" type="number" value="45" step="0.1"><label>Win %</label></div>
    <div class="row"><input id="binAvgWin" type="number" value="4.5" step="0.1"><label>Avg Winning Trade (%)</label></div>
    <div class="row"><input id="binAvgLoss" type="number" value="-2.4" step="0.1"><label>Avg Losing Trade (%)</label></div>
    <div class="row"><input id="binMaxWin" type="number" value="10" step="0.1"><label>Largest Winning Trade (%)</label></div>
    <div class="row"><input id="binMaxLoss" type="number" value="6.5" step="0.1"><label>Largest Losing Trade (%)</label></div>
  </div>

  <!-- Multinomial model -->
  <div id="multiInputs" class="hidden">
    <hr><strong>Multinomial Model</strong>
    <div class="row"><input id="weightOutlierWin" type="number" value="0.02"><label>Outlier Win Weight</label></div>
    <div class="row"><input id="weightBigWin" type="number" value="0.18"><label>Big Win Weight</label></div>
    <div class="row"><input id="weightSmallWin" type="number" value="0.25"><label>Small Win Weight</label></div>
    <div class="row"><input id="weightSmallLoss" type="number" value="0.45"><label>Small Loss Weight</label></div>
    <div class="row"><input id="weightBigLoss" type="number" value="0.09"><label>Big Loss Weight</label></div>
    <div class="row"><input id="weightOutlierLoss" type="number" value="0.01"><label>Outlier Loss Weight</label></div>

    <hr>
    <strong>Payoff Ranges (%)</strong>
    <div class="row"><input id="outlierWinMin" type="number" value="10"><input id="outlierWinMax" type="number" value="20"><label>Outlier Win</label></div>
    <div class="row"><input id="bigWinMin" type="number" value="3.5"><input id="bigWinMax" type="number" value="10"><label>Big Win</label></div>
    <div class="row"><input id="smallWinMin" type="number" value="0.01"><input id="smallWinMax" type="number" value="3.5"><label>Small Win</label></div>
    <div class="row"><input id="smallLossMin" type="number" value="-0.01"><input id="smallLossMax" type="number" value="-3.5"><label>Small Loss</label></div>
    <div class="row"><input id="bigLossMin" type="number" value="-3.5"><input id="bigLossMax" type="number" value="-7"><label>Big Loss</label></div>
    <div class="row"><input id="outlierLossMin" type="number" value="-7"><input id="outlierLossMax" type="number" value="-12"><label>Outlier Loss</label></div>
  </div>

  <button id="toggleModel">Switch to Multinomial Model</button>
  <div id="history"></div>
</div>

<!-- MAIN -->
<div class="main">
  <h1>Trading Strategy Simulator</h1>
  <div id="autoControls">
    Auto-bet:
    <input type="number" id="autoCount" value="100">
    <select id="autoSpeed">
      <option value="50">Fast</option>
      <option value="1">Ultra-Fast</option>
    </select>
    <button id="autoStart">Start</button>
    <button id="autoStop">Stop</button>
    <button id="autoRestart">Restart</button>
  </div>

  <div id="status">
    Tokens: <span id="tokens">100000</span>
  </div>

  <div id="stats">
    Bets: <span id="statBets">0</span><br>
    <span class="pf-line">Annualized Return: <span id="annualReturn">0</span>%</span><br>
    <span class="pf-line">Profit Factor: <span id="statPF">0</span></span><br>
    <span class="pf-line">Max Drawdown: <span id="drawdown">0</span>%</span><br>
    Avg Win Trade: <span id="statAvgWin">0</span>%<br>
    Avg Loss Trade: <span id="statAvgLoss">0</span>%<br>
    Win %: <span id="statWinPct">0</span>%<br>
    Longest Losing Streak: <span id="longestLosingStreak">0</span>
  </div>

  <div id="chartContainer">
    <canvas id="equityChart"></canvas>
  </div>

  <table id="yearlyTable">
    <thead>
      <tr>
        <th>Year</th><th>Return%</th><th>Max DD</th><th>PF</th><th>AvgW%</th><th>AvgL%</th><th>LLS</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <div>
    <canvas id="yearlyChart"></canvas>
  </div>
</div>

<!-- Core Logic -->
<script>
/* ===== Beta Distribution Helpers (Binary) ===== */
function randn() { let u=0,v=0; while(u===0)u=Math.random(); while(v===0)v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
function gammaMT(shape){const d=shape-1/3;const c=1/Math.sqrt(9*d);while(true){const x=randn();let v=1+c*x;if(v<=0)continue;v=v*v*v;const u=Math.random();if(u<1-0.0331*(x**4))return d*v;if(Math.log(u)<0.5*x*x+d*(1-v+Math.log(v)))return d*v;}}
function gammaRand(shape){if(shape<1){const u=Math.random();return gammaRand(shape+1)*Math.pow(u,1/shape);}return gammaMT(shape);}
function betaRand(a,b){const x=gammaRand(a);const y=gammaRand(b);return x/(x+y);}
function betaOnRange(avg,max,k=6){if(max<=0)return 0;const mu=Math.max(0,Math.min(1,avg/max));if(mu===0)return 0;if(mu===1)return max;const a=mu*k;const b=(1-mu)*k;return betaRand(a,b)*max;}
function randomWinPct(avg,max){return betaOnRange(Math.max(0,avg),Math.max(0.0001,max));}
function randomLossPct(avg,max){const absAvg=Math.abs(avg);const absMax=Math.abs(max);const draw=betaOnRange(absAvg,absMax);return -draw;}
</script>

<script>
/* ===== State ===== */
let modelMode = "binary";
let tokens = 100000;
let startingTokensVal = 100000;
let peak = 100000;
let maxDrawdown = 0;
let betCount = 0, wins = 0;
let totalWinAmount = 0, totalLossAmount = 0, totalWinPct = 0, totalLossPct = 0;
let currentLosingStreak = 0, longestLosingStreak = 0;
let autoInterval = null, ultraFastRunning = false;
const historyList = [];
const maxHistory = 200;
const equityAfterTrade = [];
const pnlTokens = [];
const pctMoves = [];
const wonFlags = [];

/* ===== Charts (Y axis on the right) ===== */
const equityCtx = document.getElementById('equityChart').getContext('2d');
const equityData = {
  labels: [0],
  datasets: [{
    label: 'Equity Curve',
    data: [tokens],
    borderColor: 'lime',
    fill: false,
    tension: 0.1
  }]
};
const equityChart = new Chart(equityCtx, {
  type: 'line',
  data: equityData,
  options: {
    responsive: false,
    maintainAspectRatio: false,
    scales: {
      x: {
        title: { display: true, text: 'Bet' },
        grid: { drawBorder: false, drawOnChartArea: false },
        ticks: { padding: 0 },
        offset: false
      },
      y: {
        position: 'right',
        title: { display: true, text: 'Tokens' },
        grid: { drawBorder: false }
      }
    }
  }
});

const yearlyCtx = document.getElementById('yearlyChart').getContext('2d');
const yearlyData = { labels: [], datasets: [] };
const yearlyChart = new Chart(yearlyCtx, {
  type: 'line',
  data: yearlyData,
  options: {
    responsive: false,
    maintainAspectRatio: false,
    plugins: { legend: { position: 'bottom' } },
    scales: {
      x: {
        title: { display: true, text: 'Trade # in Year' },
        grid: { drawBorder: false, drawOnChartArea: false },
        ticks: { padding: 0 },
        offset: false
      },
      y: {
        position: 'right',
        title: { display: true, text: 'Cumulative Return % (in-year)' },
        grid: { drawBorder: false }
      }
    }
  }
});


/* ===== UI Events ===== */
document.getElementById('toggleModel').addEventListener('click', () => {
  modelMode = (modelMode === "binary") ? "multinomial" : "binary";
  document.getElementById('binaryInputs').classList.toggle('hidden', modelMode !== "binary");
  document.getElementById('multiInputs').classList.toggle('hidden', modelMode !== "multinomial");
  document.getElementById('toggleModel').textContent = (modelMode === "binary") ? "Switch to Multinomial Model" : "Switch to Binary Model";
});
document.getElementById('autoStart').addEventListener('click', startAuto);
document.getElementById('autoStop').addEventListener('click', stopAuto);
document.getElementById('autoRestart').addEventListener('click', () => { stopAuto(); resetSimulation(); });

function startAuto() {
  const total = parseInt(document.getElementById('autoCount').value);
  const speed = parseInt(document.getElementById('autoSpeed').value);
  let count = 0;
  if (autoInterval) clearInterval(autoInterval);
  ultraFastRunning = false;
  if (speed === 1) {
    ultraFastRunning = true;
    const batchSize = 250;
    function runBatch() {
      if (!ultraFastRunning) return;
      const limit = Math.min(batchSize, total - count);
      for (let i = 0; i < limit; i++) { makeBet(); count++; }
      if (count < total) requestAnimationFrame(runBatch);
    }
    requestAnimationFrame(runBatch);
  } else {
    autoInterval = setInterval(() => {
      makeBet();
      count++;
      if (count >= total) clearInterval(autoInterval);
    }, speed);
  }
}
function stopAuto() { if (autoInterval) clearInterval(autoInterval); ultraFastRunning = false; }

/* ===== Simulation Core ===== */
function resetSimulation() {
  startingTokensVal = parseFloat(document.getElementById('startingTokens').value);
  tokens = startingTokensVal;
  peak = tokens;
  maxDrawdown = 0;
  betCount = wins = 0;
  totalWinAmount = totalLossAmount = totalWinPct = totalLossPct = 0;
  currentLosingStreak = longestLosingStreak = 0;
  historyList.length = 0;
  document.getElementById('history').innerHTML = '';
  equityAfterTrade.length = 0; pnlTokens.length = 0; pctMoves.length = 0; wonFlags.length = 0;
  equityData.labels = [0]; equityData.datasets[0].data = [tokens]; equityChart.update('none');
  document.getElementById('tokens').textContent = tokens.toFixed(2);
  updateStats();
  clearYearlyOutputs();
}

function clearYearlyOutputs() {
  const tbody = document.querySelector('#yearlyTable tbody');
  tbody.innerHTML = '';
  yearlyData.labels = [];
  yearlyData.datasets = [];
  yearlyChart.update();
}

function drawOutcome() {
  const weights = {
    outlierWin: parseFloat(weightOutlierWin.value),
    bigWin: parseFloat(weightBigWin.value),
    smallWin: parseFloat(weightSmallWin.value),
    smallLoss: parseFloat(weightSmallLoss.value),
    bigLoss: parseFloat(weightBigLoss.value),
    outlierLoss: parseFloat(weightOutlierLoss.value)
  };
  const total = Object.values(weights).reduce((a,b)=>a+b,0);
  let r = Math.random() * total;
  for (const [k,v] of Object.entries(weights)) {
    if (r <= v) return k;
    r -= v;
  }
  return "smallWin";
}
function drawMultinomialPct(type) {
  const ranges = {
    outlierWin: [outlierWinMin.value, outlierWinMax.value],
    bigWin: [bigWinMin.value, bigWinMax.value],
    smallWin: [smallWinMin.value, smallWinMax.value],
    smallLoss: [smallLossMin.value, smallLossMax.value],
    bigLoss: [bigLossMin.value, bigLossMax.value],
    outlierLoss: [outlierLossMin.value, outlierLossMax.value]
  };
  const [a,b] = ranges[type].map(parseFloat);
  return Math.min(a,b) + Math.random() * (Math.max(a,b)-Math.min(a,b));
}

function makeBet() {
  const riskType = document.getElementById('riskType').value;
  let riskInput = parseFloat(document.getElementById('tokensRisked').value);
  const risk = (riskType === 'percent') ? tokens * (riskInput/100) : riskInput;
  if (risk <= 0 || risk > tokens) return;

  let pct;
  if (modelMode === "binary") {
    const winP = parseFloat(binWinPct.value);
    const avgWin = parseFloat(binAvgWin.value);
    const avgLoss = parseFloat(binAvgLoss.value);
    const maxWin = parseFloat(binMaxWin.value);
    const maxLoss = parseFloat(binMaxLoss.value);
    const win = Math.random() * 100 < winP;
    pct = win ? randomWinPct(avgWin, maxWin) : randomLossPct(avgLoss, maxLoss);
  } else {
    pct = drawMultinomialPct(drawOutcome());
  }

  const pnl = risk * (pct / 100);
  betCount++;
  tokens += pnl;

  const isWin = pnl >= 0;
  if (isWin) {
    wins++;
    totalWinAmount += pnl;
    totalWinPct += Math.abs(pct);
    currentLosingStreak = 0;
  } else {
    totalLossAmount += Math.abs(pnl);
    totalLossPct += Math.abs(pct);
    currentLosingStreak++;
    if (currentLosingStreak > longestLosingStreak) longestLosingStreak = currentLosingStreak;
  }

  equityAfterTrade.push(tokens);
  pnlTokens.push(pnl);
  pctMoves.push(Math.abs(pct));
  wonFlags.push(isWin);

  // === dynamic classification based on configured ranges ===
  const outlierWinMinVal = parseFloat(outlierWinMin.value);
  const bigWinMinVal = parseFloat(bigWinMin.value);
  const outlierLossMinVal = Math.abs(parseFloat(outlierLossMin.value));
  const bigLossMinVal = Math.abs(parseFloat(bigLossMin.value));

  let cls;
  if (isWin) {
    if (pct >= outlierWinMinVal) cls = 'outlierWin';
    else if (pct >= bigWinMinVal) cls = 'bigWin';
    else cls = 'smallWin';
  } else {
    const lossAbs = Math.abs(pct);
    if (lossAbs >= outlierLossMinVal) cls = 'outlierLoss';
    else if (lossAbs >= bigLossMinVal) cls = 'bigLoss';
    else cls = 'smallLoss';
  }

  const line = `#${betCount} ${pnl>=0?'+':'-'}${Math.abs(pnl).toFixed(2)} (${pct.toFixed(2)}%) \u2192 ${tokens.toFixed(2)}`;
  historyList.unshift(`<span class="${cls}">${line}</span>`);
  if (historyList.length > maxHistory) historyList.pop();
  document.getElementById('history').innerHTML = historyList.join('<br>');

  document.getElementById('tokens').textContent = tokens.toFixed(2);
  equityData.labels.push(betCount); equityData.datasets[0].data.push(tokens); equityChart.update('none');

  updateStats();

  const tpy = Math.max(1, parseInt(document.getElementById('tradesPerYear').value));
  if (betCount % tpy === 0) renderYearlyOutputs();
}

function updateStats() {
  const losses = betCount - wins;
  const winPct = betCount ? (wins / betCount) * 100 : 0;
  const avgWinPct = wins ? totalWinPct / wins : 0;
  const avgLossPct = losses ? totalLossPct / losses : 0;
  const pf = totalLossAmount > 0 ? totalWinAmount / totalLossAmount : (wins ? Infinity : 0);

  document.getElementById('statBets').textContent = betCount;
  document.getElementById('statWinPct').textContent = winPct.toFixed(2);
  document.getElementById('statPF').textContent = (pf === Infinity ? '∞' : pf.toFixed(2));
  document.getElementById('statAvgWin').textContent = avgWinPct.toFixed(2);
  document.getElementById('statAvgLoss').textContent = avgLossPct.toFixed(2);
  document.getElementById('longestLosingStreak').textContent = longestLosingStreak;

  if (tokens > peak) peak = tokens;
  const dd = ((peak - tokens) / peak) * 100;
  if (dd > maxDrawdown) maxDrawdown = dd;
  document.getElementById('drawdown').textContent = maxDrawdown.toFixed(2);

  const tpy = Math.max(1, parseFloat(document.getElementById('tradesPerYear').value));
  const yearsFloat = Math.max(1, betCount / tpy);
  const cagr = Math.pow(tokens / startingTokensVal, 1 / yearsFloat) - 1;
  const val = (cagr * 100).toFixed(2);
  const el = document.getElementById('annualReturn');
  el.textContent = val;
  el.className = (cagr >= 0) ? 'green' : 'red';
}

function renderYearlyOutputs() {
  const tpy = Math.max(1, parseInt(document.getElementById('tradesPerYear').value));
  const totalTrades = betCount;
  const fullYears = Math.floor(totalTrades / tpy);
  const tbody = document.querySelector('#yearlyTable tbody');
  tbody.innerHTML = '';

  yearlyData.labels = Array.from({ length: tpy }, (_, i) => i + 1);
  yearlyData.datasets = [];

  for (let y = 0; y < fullYears; y++) {
    const startTradeIdx = y * tpy;
    const endTradeIdx = (y + 1) * tpy;

    const yearEquityStart = (startTradeIdx === 0) ? startingTokensVal : equityAfterTrade[startTradeIdx - 1];
    const yearEquitySeries = [];
    let localPeak = yearEquityStart, localMaxDD = 0;
    let yGrossProfit = 0, yGrossLoss = 0, yWins = 0, yLosses = 0;
    let yWinPctSum = 0, yLossPctSum = 0, yCurrentLS = 0, yLongestLS = 0;

    for (let i = startTradeIdx; i < endTradeIdx; i++) {
      const eq = equityAfterTrade[i];
      yearEquitySeries.push(((eq - yearEquityStart) / yearEquityStart) * 100);
      if (eq > localPeak) localPeak = eq;
      const dd = (localPeak - eq) / localPeak * 100;
      if (dd > localMaxDD) localMaxDD = dd;

      const pnl = pnlTokens[i];
      const pct = pctMoves[i];
      if (pnl >= 0) { yGrossProfit += pnl; yWins++; yWinPctSum += pct; yCurrentLS = 0; }
      else { yGrossLoss += -pnl; yLossPctSum += pct; yLosses++; yCurrentLS++; if (yCurrentLS > yLongestLS) yLongestLS = yCurrentLS; }
    }

    const yearEndEquity = equityAfterTrade[endTradeIdx - 1];
    const yearReturnPct = ((yearEndEquity - yearEquityStart) / yearEquityStart) * 100;
    const yPF = yGrossLoss > 0 ? (yGrossProfit / yGrossLoss) : (yWins ? Infinity : 0);
    const yAvgWinPct = yWins ? (yWinPctSum / yWins) : 0;
    const yAvgLossPct = yLosses ? (yLossPctSum / yLosses) : 0;

	const START_HUE = 180;
    const lineColor = `hsl(${(START_HUE + y * 70) % 360}, 100%, 50%)`

    const row = document.createElement('tr');
    row.innerHTML = `<td style="color:${lineColor}; font-weight:bold;">${y + 1}</td>
                     <td>${yearReturnPct.toFixed(2)}</td>
                     <td>${localMaxDD.toFixed(2)}</td>
                     <td>${(yPF === Infinity ? '∞' : yPF.toFixed(2))}</td>
                     <td>${yAvgWinPct.toFixed(2)}</td>
                     <td>${yAvgLossPct.toFixed(2)}</td>
                     <td>${yLongestLS}</td>`;
    tbody.appendChild(row);

    yearlyData.datasets.push({
      label: `${y + 1}`,
      data: yearEquitySeries,
      borderColor: lineColor,
      borderWidth: 2,
      fill: false,
      tension: 0.1
    });
  }
  yearlyChart.update();
}

resetSimulation();
</script>
</body>
</html>
